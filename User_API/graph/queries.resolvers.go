package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.64

import (
	"context"
	"f1betting/betting_system"
	"f1betting/user_api/graph/model"
	"f1betting/user_management"
	"fmt"
	"strconv"
)

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	userID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return nil, err
	}
	user, err := user_management.GetUserByID(ctx, r.Conn, userID)
	if err != nil {
		return nil, err
	}

	return &model.User{
		ID:                strconv.FormatInt(user.ID, 10),
		FullName:          user.FullName,
		Email:             user.Email,
		Username:          user.Username,
		DateOfBirth:       user.DateOfBirth.String(),
		PhoneNumber:       user.PhoneNumber,
		GovernmentID:      user.GovernmentID,
		Address:           user.Address,
		TaxID:             user.TaxID,
		AccountStatus:     model.AccountStatus(user.AccountStatus),
		RegistrationDate:  user.RegistrationDate.String(),
		Role:              model.UserRole(user.Role),
		EmailVerified:     user.EmailVerified,
		Country:           user.Country,
		PreferredCurrency: user.PreferredCurrency,
		FavoriteTeam:      user.FavoriteTeam,
		ProfilePictureURL: user.ProfilePictureURL,
		Balance:           user.Balance,
	}, nil

}

// UserByEmail is the resolver for the userByEmail field.
func (r *queryResolver) UserByEmail(ctx context.Context, email string) (*model.User, error) {
	panic(fmt.Errorf("not implemented: UserByEmail - userByEmail"))
}

// UserByUsername is the resolver for the userByUsername field.
func (r *queryResolver) UserByUsername(ctx context.Context, username string) (*model.User, error) {
	panic(fmt.Errorf("not implemented: UserByUsername - userByUsername"))
}

// UserActiveBets is the resolver for the userActiveBets field.
func (r *queryResolver) UserActiveBets(ctx context.Context, userID string) ([]model.Bet, error) {
	panic(fmt.Errorf("not implemented: UserActiveBets - userActiveBets"))
}

// UserBetHistory is the resolver for the userBetHistory field.
func (r *queryResolver) UserBetHistory(ctx context.Context, userID string) ([]model.Bet, error) {
	panic(fmt.Errorf("not implemented: UserBetHistory - userBetHistory"))
}

// SessionPodiumBets is the resolver for the sessionPodiumBets field.
func (r *queryResolver) SessionPodiumBets(ctx context.Context, sessionID int32, status *model.BetStatus) ([]*model.PodiumBet, error) {
	panic(fmt.Errorf("not implemented: SessionPodiumBets - sessionPodiumBets"))
}

// SessionPolePositionBets is the resolver for the sessionPolePositionBets field.
func (r *queryResolver) SessionPolePositionBets(ctx context.Context, sessionID int32, status *model.BetStatus) ([]*model.PolePositionBet, error) {
	panic(fmt.Errorf("not implemented: SessionPolePositionBets - sessionPolePositionBets"))
}

// SessionRainBets is the resolver for the sessionRainBets field.
func (r *queryResolver) SessionRainBets(ctx context.Context, sessionID int32, status *model.BetStatus) ([]*model.RainBet, error) {
	panic(fmt.Errorf("not implemented: SessionRainBets - sessionRainBets"))
}

// SessionRetirementBets is the resolver for the sessionRetirementBets field.
func (r *queryResolver) SessionRetirementBets(ctx context.Context, sessionID int32, status *model.BetStatus) ([]*model.RetirementBet, error) {
	panic(fmt.Errorf("not implemented: SessionRetirementBets - sessionRetirementBets"))
}

// SessionFastestLapBets is the resolver for the sessionFastestLapBets field.
func (r *queryResolver) SessionFastestLapBets(ctx context.Context, sessionID int32, status *model.BetStatus) ([]*model.FastestLapBet, error) {
	var betStatus string
	if status != nil {
		betStatus = status.String()
	} else {
		betStatus = "PENDING"
	}

	bets, err := betting_system.GetFastestLapBetsByRace(ctx, r.Conn, int64(sessionID), betStatus)
	if err != nil {
		return nil, err
	}

	var result []*model.FastestLapBet
	for _, bet := range *bets {
		result = append(result, &model.FastestLapBet{
			ID:          strconv.FormatInt(bet.ID, 10),
			UserID:      strconv.FormatInt(bet.UserID, 10),
			SessionID:   sessionID,
			DriverID:    int32(bet.DriverID),
			Status:      model.BetStatus(bet.Status),
			BettingPool: int32(bet.BettingPool),
			CreatedAt:   bet.CreateAt.String(),
		})
	}

	return result, nil
}

// SessionLapTimingBets is the resolver for the sessionLapTimingBets field.
func (r *queryResolver) SessionLapTimingBets(ctx context.Context, sessionID int32, status *model.BetStatus) ([]*model.LapTimingBet, error) {
	panic(fmt.Errorf("not implemented: SessionLapTimingBets - sessionLapTimingBets"))
}

// PendingBetsForSession is the resolver for the pendingBetsForSession field.
func (r *queryResolver) PendingBetsForSession(ctx context.Context, sessionID int32) ([]model.Bet, error) {
	panic(fmt.Errorf("not implemented: PendingBetsForSession - pendingBetsForSession"))
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
